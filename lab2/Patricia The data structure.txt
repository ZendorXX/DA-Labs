Patricia
The data structure Patricia (Practical Algorithm To Retrieve Information Coded In Alphanumeric) is a compressed binary trie in which the branch and element nodes have been melded into a single node type. Consider the compressed binary trie of Figure 28.18. Circular nodes are branch nodes and rectangular nodes are element nodes. The number inside a branch node is its bit number field; the left child of a branch node corresponds to the case when the appropriate key bit is 0 and the right child to the case when this bit is 1. The melding of branch and element nodes is done by moving each element from its element node to an ancestor branch node. Since the number of branch nodes is one less than the number of element nodes, we introduce a header node and make the compressed binary trie the left subtree of the header. Pointers that originally went from a branch node to an element node now go from that branch node to the branch node into which the corresponding element has been melded. Figure 28.19 shows a possible result of melding the nodes of Figure 28.18. The number outside a node is its bit number values. The thick pointers are backward pointers that replace branch-node to element-node pointers in Figure 28.18. A backward pointer has the property that the bit number value at the start of the pointer is ≥ the bit number value at its end. For original branch-node to branch-node pointers (also called downward pointers), the bit number value at the pointer end is always greater than the bit number value at the pointer start.

Searching
To search for an element with key theKey, we use the bits of theKey from left to right to move down the Patricia instance just as we would search a compressed binary trie. When a backward pointer is followed, we compare theKey with the key in the reached Patricia node. For example, to search for theKey = 1101, we start by moving into the left subtree of the header node. The pointer that is followed is a downward pointer (start bit number is 0 and end bit number is 1). We branch using bit 1 of theKey. Since this bit is 1, we follow the right child pointer. The start bit number for this pointer is 1 and the end bit number is 2. So, again, a downward pointer has been followed. The bit number for the reached node is 2. So, we use bit 2 of theKey to move further. Bit 2 is a 1. So, we use the right child pointer to get to the node that contains 1100. Again, a downward pointer was used. From this node, a move is made using bit 4 of theKey. This gets us to the node that contains 1101. This time, a backward pointer was followed (start bit of pointer is 4 and end bit is 1). When a backward pointer is followed, we compare theKey with the key in the reached node. In this case, the keys match and we have found the desired element. Notice that the same search path is taken when theKey = 1111. In this case, the final compare fails and we conclude that we have no element whose key is 1111.  

Inserting an Element
We use an example to illustrate the insert algorithm. We start with an empty instance. Such an instance has no node; not even the header. For our example, we will consider keys that have 7 bits. For the first insert, we use the key 0000101. When inserting into an empty instance, we create a header node whose left child pointer points to the header node; the new element is inserted into the header; and the bit number field of the header set to 0. The configuration of Figure 28.20(a) results. Note that the right child field of the header
node is not used.The key for the next insert is 0000000. The search for this key terminates at the header. We compare the insert key and the header key and determine that the first bit at which they diﬀer is bit 5. So, we create a new node with bit number field 5 and insert the new element into this node. Since bit 5 of the insert key is 0, the left child pointer of the new node points to the new node and the right child pointer to the header node (Figure 28.20(b)). For the next insertion, assume that the key is 0000010. The search for this key terminates at the node with 0000000. Comparing the two keys, we determine that the first bit at which the two keys diﬀer is bit 6. So, we create a new node with bit number field 6 and put the new element into this new node. The new node is inserted into the search path in such a way that bit number fields increase along this path. For our example, the new node is inserted as the left child of the node with 0000000. Since bit 6 of the insert key is 1, the right child pointer of the new node is a self pointer and the left child pointer points to the node with 0000000. Figure 28.20(c) shows the result. The general strategy to insert an element other than the first one is given below. The key of the element to be inserted is theKey.
1. Search for theKey. Let reachedKey be the key in the node endN ode where the search terminates.
2. Determine the leftmost bit position lBitP os at which theKey and reachedKey diﬀer. lBitP os is well defined so long as one of the two keys isn’t a prefix of the other.
3. Create a new node with bit number field lBitP os. Insert this node into the search path from the header to endN ode so that bit numbers increase along this path. This insertion breaks a pointer from node p to node q. The pointer now goes from p to the new node.
4. If bit lBitP os of theKey is 1, the right child pointer of the new node becomes a self pointer (i.e., it points to the new node); otherwise, the left child pointer of the new node becomes a self pointer. The remaining child pointer of the new node points to q.
For our next insert, the insert key is 0001000. The search for this key terminates at the node with 0000000. We determine that the first bit at which the insert key and reachedKey = 0000000 diﬀer is bit 4. We create a new node with bit number 4 and put the new element into this node. The new node is inserted on the search path so as to ensure that bit number fields increase along this path. So, the new node is inserted as the left child of the header node (Figure 28.18(d)). This breaks the pointer from the header to the node q with 0000000. Since bit 4 of the insert key is 1, the right child pointer of the new node is a self pointer and the left child pointer goes to node q.
We consider two more inserts. Consider inserting an element whose key is 0000100. The reached key is 0000101 (in the header). We see that the first bit at which the insert and
reached keys diﬀer is bit 7. So, we create a new node with bit number 7; the new element is put into the new node; the new node is inserted into the search path so as to ensure that
bit numbers increase along this path (this requires the new node to be made a right child of the node with 0000000, breaking the child pointer from 0000000 to the header); for the
broken pointer, p is the node with 0000000 and q is the header; the left child pointer of the new node is a self pointer (because bit 7 of the insert key is 0); and remaining child pointer (in this case the right child) of the new node points to q (see Figure 28.21(a)). For our final insert, the insert key is 0001010. A search for this key terminates at the
node with 0000100. The first bit at which the insert and reached keys diﬀer is bit 6. So, we create a new node with bit number 6; the new element is put into the new node; the new
node is inserted into the search path so as to ensure that bit numbers increase along this path (this requires the new node to be made a right child of the node with 0001000; so, p = q = node with 001000); the right child pointer of the new node is a self pointer (because bit 6 of the insert key is 1); and the remaining child (in this case the left child) of the new node is q (see Figure 28.21(b)).

Removing an Element
Let p be the node that contains the element that is to be removed. We consider two cases for p—(a) p has a self pointer and (b) p has no self pointer. When p has a self pointer
and p is the header, the Patricia instance becomes empty following the element removal (Figure 28.20(a)). In this case, we simply dispose of the header. When p has a self pointer
and p is not the header, we set the pointer from the parent of p to the value of p’s non-self pointer. Following this pointer change, the node p is disposed. For example, to remove the element with key 0000010 from Figure 28.21(a), we change the left child pointer in the node with 0000000 to point to the node pointed at by p’s non-self pointer (i.e., the node with 0000000). This causes the left child pointer of 0000000 to become a self pointer. The node with 0000010 is then disposed. For the second case, we first find the node q that has a backward pointer to node p. For example, when we are to remove 0001000 from Figure 28.21(b), the node q is the node with 0001010. The element qElement in q (in our example, 0001010) is moved to node p and we proceed to delete node q instead of node p. Notice that node q is the node from which we reached node p in the search for the element that is to be removed. To delete node q, we first find the node r that has a back pointer to q (for our example r = q). The node r is found by using the key of qElement. Once r is found, the back pointer to q that is in r is changed from q to p to properly account for the fact that we have moved qElement to p. Finally, the downward pointer from the parent of q to q is changed to q’s child pointer that was used to locate r. In our example p is the parent of q and the right child pointer of p is changed from q to the right child of q, which itself was just changed to p. We see that the time for each of the Patricia operations search, insert, and delete is O(h), where h is the height of the Patricia instance. For more information on Patricia and general tries, see [2, 3].	


Patricia
Структура данных Patricia (Practical Algorithm To Retrieve Information Coded In Alphanumeric) представляет собой сжатую двоичную тройку, в которой узлы ветвей и элементов объединены в один тип узла. Рассмотрим сжатую двоичную тройку на рис. 28.18. Круглые узлы - это узлы ветвей, а прямоугольные узлы - узлы элементов. Число внутри узла ветвления - это его поле номера бита; левый ребенок узла ветвления соответствует случаю, когда соответствующий ключевой бит равен 0, а правый - случаю, когда этот бит равен 1. Объединение узлов ветвления и элементов происходит путем перемещения каждого элемента из узла элемента в узел предка узла ветвления. Поскольку количество узлов ветвей на один меньше количества узлов элементов, мы вводим узел заголовка и делаем сжатую двоичную тройку левым поддеревом заголовка. Указатели, которые первоначально шли от узла ветви к узлу элемента, теперь идут от узла ветви к узлу ветви, в который был объединен соответствующий элемент. На рис. 28.19 показан возможный результат объединения узлов на рис. 28.18. Номера вне узла - это значения его битовых номеров. Толстые указатели - это обратные указатели, которые заменяют указатели ветвь-узел-элемент-узел на рис. 28.18. Обратный указатель обладает тем свойством, что значение номера бита в начале указателя равно ≥ значения номера бита в его конце. Для исходных указателей "ветвь-узел-ветвь-узел" (также называемых нисходящими указателями) значение номера бита в конце указателя всегда больше, чем значение номера бита в начале указателя.

Поиск по адресу
Чтобы найти элемент с ключом theKey, мы используем биты theKey слева направо для перемещения вниз по экземпляру Patricia, как при поиске сжатого двоичного трио. При переходе по обратному указателю мы сравниваем theKey с ключом в достигнутом узле Patricia. Например, чтобы найти theKey = 1101, мы начинаем с перемещения в левое поддерево головного узла. Указатель, за которым мы следуем, является нисходящим указателем (номер начального бита равен 0, а номер конечного бита равен 1). Мы ветвимся, используя бит 1 из theKey. Поскольку этот бит равен 1, мы следуем за правым дочерним указателем. Номер начального бита для этого указателя равен 1, а номер конечного бита - 2. Таким образом, снова был пройден нисходящий указатель. Номер бита для достигнутого узла равен 2. Поэтому для дальнейшего движения мы используем бит 2 ключа. Бит 2 - это 1. Значит, мы используем правый дочерний указатель, чтобы добраться до узла, содержащего 1100. Снова был использован нисходящий указатель. Из этого узла выполняется перемещение с помощью бита 4 ключа. В результате мы попадаем в узел, содержащий 1101. На этот раз был использован указатель назад (начальный бит указателя равен 4, а конечный - 1). При переходе по обратному указателю мы сравниваем ключKey с ключом в достигнутом узле. В данном случае ключи совпали, и мы нашли нужный элемент. Обратите внимание, что тот же путь поиска выполняется, когда theKey = 1111. В этом случае финальное сравнение не удается, и мы приходим к выводу, что у нас нет элемента, ключ которого равен 1111. 

Вставка элемента
Мы используем пример, чтобы проиллюстрировать алгоритм вставки. Начнем с пустого экземпляра. У такого экземпляра нет ни одного узла, даже заголовка. В нашем примере мы будем рассматривать ключи, состоящие из 7 бит. Для первой вставки мы используем ключ 0000101. При вставке в пустой экземпляр мы создаем узел заголовка, левый дочерний указатель которого указывает на узел заголовка; новый элемент вставляется в заголовок, а поле номера бита в заголовке устанавливается в 0. В результате получается конфигурация, показанная на рис. 28.20(a). Обратите внимание, что правое дочернее поле узла заголовка
не используется. Ключ для следующей вставки - 0000000. Поиск этого ключа заканчивается в заголовке. Мы сравниваем ключ вставки и ключ заголовка и определяем, что первый бит, в котором они расходятся, - бит 5. Поэтому мы создаем новый узел с полем номера бита 5 и вставляем новый элемент в этот узел. Поскольку бит 5 ключа вставки равен 0, левый дочерний указатель нового узла указывает на новый узел, а правый дочерний указатель - на узел заголовка (рис. 28.20(b)). Для следующей вставки предположим, что ключ 0000010. Поиск этого ключа заканчивается в узле с номером 0000000. Сравнивая два ключа, мы определяем, что первый бит, в котором оба ключа различаются, - это бит 6. Поэтому мы создаем новый узел с полем номера бита 6 и помещаем новый элемент в этот новый узел. Новый узел вставляется в путь поиска таким образом, чтобы поля битовых номеров увеличивались на этом пути. В нашем примере новый узел вставляется как левый ребенок узла с номером 0000000. Поскольку бит 6 ключа insert равен 1, правый дочерний указатель нового узла - это указатель self, а левый дочерний указатель указывает на узел с номером 0000000. На рис. 28.20(c) показан результат. Общая стратегия вставки элемента, отличного от первого, приведена ниже. Ключ вставляемого элемента - theKey.
1. Выполните поиск theKey. Пусть reachedKey - это ключ в узле endNode, на котором заканчивается поиск.
2. Определите позицию крайнего левого бита lBitPos, в которой theKey и reachedKey различаются. lBitPos хорошо определена, если один из двух ключей не является префиксом другого.
3. Создайте новый узел с полем номера бита lBitPos. Вставьте этот узел в путь поиска от заголовка до endNode так, чтобы номера битов увеличивались на этом пути. Эта вставка разбивает указатель от узла p к узлу q. Теперь указатель переходит от p к новому узлу.
4. Если бит lBitPos в theKey равен 1, правый дочерний указатель нового узла становится самоуказателем (т. е. указывает на новый узел); в противном случае левый дочерний указатель нового узла становится самоуказателем. Оставшийся дочерний указатель нового узла указывает на q.
Для нашей следующей вставки ключ вставки - 0001000. Поиск этого ключа заканчивается в узле с номером 0000000. Мы определяем, что первый бит, в котором находится ключ вставки и достигается Key = 0000000 diﬀer, - это бит 4. Создаем новый узел с номером бита 4 и помещаем новый элемент в этот узел. Новый узел вставляется на пути поиска таким образом, чтобы обеспечить увеличение полей битовых чисел на этом пути. Таким образом, новый узел вставляется как левый ребенок узла заголовка (рис. 28.18(d)). При этом указатель из заголовка на узел q разбивается на 0000000. Поскольку бит 4 ключа вставки равен 1, правый дочерний указатель нового узла является самоуказателем, а левый дочерний указатель переходит на узел q.
Мы рассмотрим еще две вставки. Рассмотрим вставку элемента, ключ которого 0000100. Достигнутый ключ - 0000101 (в заголовке). Мы видим, что первый бит, в котором вставляемый и
достигаемых ключей различаются, является бит 7. Поэтому мы создаем новый узел с номером бита 7; новый элемент помещается в новый узел; новый узел вставляется в путь поиска таким образом, чтобы номера битов увеличивались на этом пути (для этого нужно сделать новый узел правым потомком узла с номером 0000000, разбив дочерний указатель с 0000000 на заголовок); для сломанного указателя, p - узел с номером 0000000, а q - заголовок; левый дочерний указатель нового узла - это указатель self (потому что бит 7 ключа вставки равен 0); а оставшийся дочерний указатель (в данном случае правый) нового узла указывает на q (см. рис. 28.21(a)). Для нашей последней вставки ключ вставки равен 0001010. Поиск этого ключа заканчивается в
узле с номером 0000100. Первый бит, на котором различаются ключи вставки и достижения, - бит 6. Поэтому мы создаем новый узел с битом 6; новый элемент помещаем в новый узел; новый
вставляется в путь поиска таким образом, чтобы номера битов увеличивались вдоль этого пути (для этого нужно сделать новый узел правым ребенком узла с номером 0001000; таким образом, p = q = узел с номером 001000); правый дочерний указатель нового узла является указателем self (поскольку бит 6 ключа insert равен 1); а оставшийся ребенок (в данном случае левый) нового узла - q (см. рис. 28.21(b)).

Удаление элемента
Пусть p - узел, содержащий элемент, который нужно удалить. Мы рассмотрим два случая для p - (a) p имеет self-указатель и (b) p не имеет self-указателя. Если p имеет указатель self
и p является заголовком, экземпляр Patricia становится пустым после удаления элемента (рис. 28.20(a)). В этом случае мы просто избавляемся от заголовка. Если у p есть self-указатель
и p не является заголовком, мы устанавливаем указатель от родителя p на значение несамостоятельного указателя p. После этой смены указателя узел p утилизируется. Например, чтобы удалить элемент с ключом 0000010 с рис. 28.21(a), мы изменяем левый дочерний указатель узла 0000000 на указатель, на который указывает несамостоятельный указатель узла p (т. е. узел 0000000). В результате левый дочерний указатель 0000000 становится self-указателем. После этого узел с номером 0000010 утилизируется. Во втором случае мы сначала находим узел q, который имеет обратный указатель на узел p. Например, когда мы должны удалить 0001000 с рис. 28.21(b), узел q - это узел с 0001010. Элемент qElement в q (в нашем примере 0001010) перемещается в узел p, и мы переходим к удалению узла q вместо узла p. Обратите внимание, что узел q - это узел, из которого мы вышли на узел p в поисках элемента, который нужно удалить. Чтобы удалить узел q, мы сначала находим узел r, который имеет обратный указатель на q (для нашего примера r = q). Узел r находится с помощью ключа qElement. После того как r найден, обратный указатель на q, находящийся в r, изменяется с q на p, чтобы правильно учесть тот факт, что мы переместили qElement в p. Наконец, нисходящий указатель от родителя q к q изменяется на дочерний указатель q, который использовался для нахождения r. В нашем примере p является родителем q, и правый дочерний указатель p меняется с q на правого ребенка q, который сам только что был изменен на p. Мы видим, что время выполнения каждой из операций Patricia - поиска, вставки и удаления - равно O(h), где h - высота экземпляра Patricia. Более подробную информацию о Patricia и общих попытках см. в [2, 3].
